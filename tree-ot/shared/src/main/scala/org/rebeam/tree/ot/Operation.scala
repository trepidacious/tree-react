package org.rebeam.tree.ot

import scala.annotation.tailrec

/**
  * An operation is a sequence of Atoms, specifying a modification to a List[A].
  *
  * Guarantees an invariant that all operations having the same effect will be equal,
  * by ensuring that:
  *   1.  Consecutive atoms of the same type are merged (Atom(m) + Atom(n) = Atom(m+n), where
  *       m and n are the count for Retain and Delete, and the inserted elements for Insert)
  *   2.  Any (Delete, Insert) pair is swapped to the (Insert, Delete) pair with the same effect.
  *
  * When 1 and 2 are applied recursively, we can see that we will only be left with operations
  * that consist of a sequence made up of consecutive subsequences in two classes - either
  * just [Retain] (call this R), or one of [Insert], [Delete] or [Insert, Delete] (call this O).
  * We require that the classes alternate - so we can have [R], [ROROR], [OROR] etc.
  * The Atoms could probably be encoded differently - most obviously by combining insert and delete,
  * but the Retain/Insert/Delete encoding is canonical.
  *
  * Provides a builder-style interface for constructing operations, which maintains
  * invariants.
  *
  * @param atoms        The atoms to be applied to the list, in order
  * @param priority     The priority of the operation. When operations are transformed, this is used as
  *                     a tie-breaker for insertions at the same position. The higher priority is inserted
  *                     first. We use this approach so that if the priority is an incrementing client identifier,
  *                     more-recently connected clients will take priority over older ones.
  *                     If the priorities of both operations are the same, the tie will be broken according to
  *                     whether the operation is an authoritative server operation in the server's history, in which
  *                     case it takes priority, or a client operation. Transformations are always between a server
  *                     and a client operation.
  *                     Defaults to 0, allowing for use of just server/client priority.
  *
  * @tparam A           The operation will modify lists of this element type
  */
case class Operation[A](atoms: List[Atom[A]], priority: Long = 0) {

  import Atom._

  /**
    * The operation can be applied to input lists of exactly this size
    */
  lazy val inputSize: Int = atoms.foldLeft(0){case (s, a) => s + a.inputLengthDelta}

  /**
    * The operation will produce lists of exactly this size when applied
    */
  lazy val outputSize: Int = atoms.foldLeft(0){case (s, a) => s + a.outputLengthDelta}

  /**
    * True if operation always produces output equal to input, false otherwise
    * @return True if operation is identity
    */
  def isIdentity: Boolean = !atoms.exists {
    case Retain(_) => false
    case _ => true
  }

  /**
    * Apply the operation to an input list
    * @param input  The input list to operate on. Must have size equal to operation's inputSize
    * @return       The output list generated by the operation on the input list.
    */
  def apply(input: List[A]): List[A] = {
    require(input.size == inputSize, s"can only apply to correct input size $inputSize, received ${input.size}")

    val (remainingInput, output) =
      atoms.foldLeft((input, List.empty[A])) {

        // i is remaining input, o is our output, a is the current atom
        case ((i, o), a) => a match {

          // Copy n elements from input to output, checking we have enough
          case Retain(n) =>
            require(i.size >= n, s"only ${i.size} elements in input on retain($n)")
            (i.drop(n), o ++ i.take(n))

          // Append elements to output
          case Insert(l) =>
            (i, o ++ l)

          // Discard n elements from input, checking we have enough
          case Delete(n) =>
            require(i.size >= n, s"only ${i.size} elements in input on delete($n)")
            (i.drop(n), o)
        }
      }

    // Require that operation has used the entire input
    require(remainingInput.isEmpty, "input not empty after operation")

    output
  }

  def inverse(input: List[A]): Operation[A] = {
    require(input.size == inputSize, s"inverse input size ${input.size} != operation input size $inputSize")

    val (remainingInput, inverse) =
      atoms.foldLeft((input, OperationBuilder.empty[A])) {

        // i is remaining input, o is our output - the inverse, a is the current atom
        case ((i, o), a) => a match {

          // Retaining is the same in operation and inverse
          case Retain(n) =>
            require(i.size >= n, s"only ${i.size} elements in input on retain($n)")
            (i.drop(n), o.retain(n))

          // Invert inserting by deleting the same number of elements
          case Insert(l) =>
            (i, o.delete(l.size))

          // Invert deleting by reinserting the deleted elements
          case Delete(n) =>
            require(i.size >= n, s"only ${i.size} elements in input on delete($n)")
            (i.drop(n), o.insert(i.take(n)))

        }
      }

    // Require that operation has used the entire input
    require(remainingInput.isEmpty, "input not empty after operation inverted")

    inverse.build.copy(priority = priority)
  }

  /**
    * Compose this operation (a) with another (b), to produce a new operation c that will achieve the same result as
    * applying a then b.
    *
    * This means that:
    *
    * b(a(s)) == (a.compose(b))(s)
    *
    * for any input list s
    *
    * The result will inherit the priority of this operation
    *
    * @param b  Another operation
    * @return   An operation equivalent to this operation, then operation b
    */
  def compose(b: Operation[A]): Operation[A] = {
    val a = this

    //a's output size must match b's expected input size
    require(a.outputSize == b.inputSize, s"compose on mismatched output size ${a.outputSize} and input size ${b.inputSize}")

//    Operation.composeRec(this.atoms, b.atoms, Operation.empty(priority))

    // Use builder for efficiency
    Operation.composeRec(this.atoms, b.atoms, OperationBuilder.empty).build.copy(priority = priority)
  }

  /**
    * This transforms this operation against operation b, using transform. If this operation has a higher
    * priority than b it is transformed as the left-hand operation (with higher priority, to insert first in
    * the case of a tie), if it is lower priority it is transformed as the right hand operation.
    *
    * This operation must have different priority to b, otherwise a sys.error is raised.
    *
    * @param b   The operation we wish to apply before this one
    * @return    This operation transformed so it can be applied after `b`.
    */
  def after(b: Operation[A]): Operation[A] = if (priority > b.priority) {
    Operation.transform(this, b)._1
  } else if (priority < b.priority) {
    Operation.transform(b, this)._2
  } else {
    sys.error("Operation.after requires operations to have different priorities")
  }

  /**
    * This is just the first element in the pair returned by `Operation.transform(this, clientOp)`.
    *
    * This is intended for use to transform server operations - this means that operations performed
    * on the server are always given priority, for example when breaking ties arising from the two
    * operations inserting at the same location (the server insertion will be placed just before the
    * client insertion in the resulting list).
    *
    * So if we call this operation `serverOp`, we have:
    *
    * serverOp.serverAfter(clientOp)(clientOp(s)) == clientOp.clientAfter(serverOp)(serverOp(s))
    * for any input list `s`.
    *
    * @param clientOp   The operation we wish to apply before this one, taken to be a client operation.
    * @return           This operation transformed so it can be applied after `clientOp`.
    */
  def serverAfter(clientOp: Operation[A]): Operation[A] = {
    if (priority != clientOp.priority) {
      after(clientOp)
    } else {
      Operation.transform(this, clientOp)._1
    }
  }

  /**
    * As for serverAfter, but accepting an optional operation, treating None as no operation.
    * @param clientOp   The operation we wish to apply before this one, taken to be a client operation, or none
    *                   to leave this operation unaltered.
    * @return           This operation transformed so it can be applied after `clientOp`.
    */
  def serverAfterOptional(clientOp: Option[Operation[A]]): Operation[A] = clientOp match {
    case None => this
    case Some(c) => serverAfter(c)
  }

  /**
    * This is just the second element in the pair returned by `Operation.transform(serverOp, this)`.
    * So if we call this operation `clientOp`, we have:
    *
    * This is intended for use to transform client operations - this means that operations performed
    * on the server are always given priority, for example when breaking ties arising from the two
    * operations inserting at the same location (the server insertion will be placed just before the
    * client insertion in the resulting list).
    *
    * clientOp.clientAfter(serverOp)(serverOp(s)) == serverOp.serverAfter(clientOp)(clientOp(s))
    * for any input list s.
    *
    * @param serverOp   The operation we wish to apply before this one.
    * @return           This operation transformed so it can be applied after b.
    */
  def clientAfter(serverOp: Operation[A]): Operation[A] = {
    if (priority != serverOp.priority) {
      after(serverOp)
    } else {
      Operation.transform(serverOp, this)._2
    }
  }

  /**
    * This is just the second element in the pair returned by `Operation.transform(serverOp, this)`.
    * So if we call this operation `clientOp`, we have:
    *
    * This is intended for use to transform client operations - this means that operations performed
    * on the server are always given priority, for example when breaking ties arising from the two
    * operations inserting at the same location (the server insertion will be placed just before the
    * client insertion in the resulting list).
    *
    * clientOp.clientAfter(serverOp)(serverOp(s)) == serverOp.serverAfter(clientOp)(clientOp(s))
    * for any input list s.
    *
    * @param serverOp   The operation we wish to apply before this one.
    * @return           This operation transformed so it can be applied after b.
    */
  def clientAfterOptional(serverOp: Option[Operation[A]]): Operation[A] = serverOp match {
    case None => this
    case Some(s) => clientAfter(s)
  }

  def transformCursor(cursorIndex: Int, isEditor: Boolean): Int =
    transformCursorRec(cursorIndex, isEditor, atoms, opIndex = 0)

  //opIndex tracks the point at which the first atom in atoms will be applied
  @tailrec
  private def transformCursorRec(cursorIndex: Int, isEditor: Boolean, atoms: List[Atom[A]], opIndex: Int): Int = atoms match {
    case Retain(n) :: rest =>
      val nextOpIndex = opIndex + n
      // We are past the cursor - ignore remaining atoms
      if (nextOpIndex > cursorIndex) {
        cursorIndex
      // Move to next atom, with the next op index
      } else {
        transformCursorRec(cursorIndex, isEditor, rest, nextOpIndex)
      }

    case Insert(as) :: rest =>
      val size = as.size
      val nextOpIndex = opIndex + size
      // Shouldn't happen, but ignore insert after cursorIndex
      if (opIndex > cursorIndex) {
        cursorIndex

      // Insert at or before the cursor
      } else {
        // Insertion before the cursor moves cursor right.
        // Insertion at the cursor only moves cursor if this cursor
        // is the editor. Otherwise we let the other cursor add text
        // after the cursor we are handling.
        val nextCursorIndex = if (isEditor || opIndex < cursorIndex) {
          cursorIndex + size
        } else {
          cursorIndex
        }
        transformCursorRec(nextCursorIndex, isEditor, rest, nextOpIndex)
      }

    case Delete(n) :: rest =>
      // Shouldn't happen, but ignore delete at or after cursorIndex
      if (opIndex >= cursorIndex) {
        cursorIndex

      // Deletion starting before the cursor will affect cursorIndex
      } else {
        // Note that we can't move the cursor back before the opIndex - this
        // corresponds to when the cursor is inside the deleted range.
        val nextCursorIndex = cursorIndex - Math.min(n, cursorIndex - opIndex)
        transformCursorRec(nextCursorIndex, isEditor, rest, opIndex)
      }

    case Nil => cursorIndex
  }

}

object Operation {
  import Atom._

  def empty[A](priority: Long = 0): Operation[A] = Operation(Nil, priority)

  def fromAtoms[A](atoms: List[Atom[A]], priority: Long = 0): Operation[A] = atoms.foldLeft(OperationBuilder.empty[A]){
    case (op, atom) => op.andThen(atom)
  }.build.copy(priority = priority)

//  def fromAtoms[A](atoms: Atom[A]*): Operation[A] = fromAtoms(atoms.toList)

  private implicit class ListOps[A](list: List[A]) {
    def next: List[A] = list.tail //list.drop(1)
    def withHead(a: A): List[A] = a :: list.tail //list.updated(0, a)
  }

  /**
    * This is the basis of operational transform. We take two concurrent operations
    * a and b, that would be applied to the same list of elements, and we produce a pair of new
    * operations(ap, bp), such that:
    *
    * bp(a(s)) = ap(b(s))
    *
    * for any input list s
    *
    * Imagine client alice has applied operation a, and client bob has applied operation b, and we need
    * to bring them back to the same state, preserving both their edits.
    *
    * We can do this by sending bp to alice to apply on top of a, and sending ap to bob to apply on top of b.
    * They will then both end up at the same result, with both of their operations applied.
    *
    * In general, this allows for a system where a server applies operations from a set of clients in the order
    * they are received at the server, but where those operations are transformed so they preserve the intent of the
    * client, allowing for other client's operations that modified the server state concurrently.
    *
    * @param a  The first operation
    * @param b  The second operation
    * @tparam A The type of element in the lists to which operations apply
    * @return   A pair of operations (ap, bp) transformed appropriately from (a, b)
    */
  def transform[A](a: Operation[A], b: Operation[A]): (Operation[A], Operation[A]) = {
    require(a.inputSize == b.inputSize, "transform requires operations to have same input size")
    //We use builder here for efficiency
    val (builderA, builderB) = transformRec(a.atoms, b.atoms, OperationBuilder.empty, OperationBuilder.empty)
    (builderA.build.copy(priority = a.priority), builderB.build.copy(priority = b.priority))

//    transformRec(a.atoms, b.atoms, Operation.empty(a.priority), Operation.empty(b.priority))
  }

  @tailrec
//  private def transformRec[A](as1: List[Atom[A]], as2: List[Atom[A]], p1: Operation[A], p2: Operation[A]): (Operation[A], Operation[A]) =
  private def transformRec[A](as1: List[Atom[A]], as2: List[Atom[A]], p1: OperationBuilder[A], p2: OperationBuilder[A]): (OperationBuilder[A], OperationBuilder[A]) =

    // At each recursion, we look at what operation 1 and 2 do, and append operations to p1 that will achieve the same
    // effect as operation 1, on the results of operation 2. In the same way we append to p2 operations that will achieve
    // the same effect as operation 2, on the results of operation 1.

    // So for example if operation 1 inserts some elements, these elements will need to be added to p1, adapted as
    // necessary to work with the atoms of operation 2.

    // At each recursion, the cursor associated with both operations must be at the same position in the input list

    (as1.headOption, as2.headOption) match {

      // If we have processed all atoms, we are done
      case (None, None) => (p1, p2)

      // If either operation's atom is an insert, perform the insert on the respective prime operation,
      // and retain the already-inserted elements on the other prime operation. Handle insert in operation 1 first.
      case (Some(Insert(l1)), _) =>
        transformRec(as1.next, as2, p1.insert(l1), p2.retain(l1.size))
      case (_, Some(Insert(l2))) =>
        transformRec(as1, as2.next, p1.retain(l2.size), p2.insert(l2))

      // ERR1 Need operation 1 atom
      case (None, _) =>
        sys.error("Transforming operations, we ran out of atoms in the first operation")

      // ERR2 Need operation 2 atom
      case (_, None) =>
        sys.error("Transforming operations, we ran out of atoms in the second operation")

      // Both operations retain
      case (Some(Retain(n1)), Some(Retain(n2))) =>
        // Operation 1 retains more - split this retain, and append operation 2's smaller retain to prime operations
        if (n1 > n2) {
          transformRec(as1.withHead(Retain(n1 - n2)), as2.next, p1.retain(n2), p2.retain(n2))

        // Same length - just append
        } else if (n1 == n2) {
          transformRec(as1.next, as2.next, p1.retain(n1), p2.retain(n1))

        // Operation 2 retains more - split this retain, and append operation 1's smaller retain to prime operations
        } else {
          transformRec(as1.next, as2.withHead(Retain(n2 - n1)), p1.retain(n1), p2.retain(n1))
        }

      // Both operations delete
      case (Some(Delete(n1)), Some(Delete(n2))) =>
        // Both operations delete the first n2 elements, this needs no additional prime atoms since both operations
        // already do the same thing. But we will need to deal with the extra elements deleted by operation 1.
        if (n1 > n2) {
          transformRec(as1.withHead(Delete(n1 - n2)), as2.next, p1, p2)

        // Both operations delete the same characters - nothing to do in prime operations, each operation already
        // achieves the same thing
        } else if (n1 == n2) {
          transformRec(as1.next, as2.next, p1, p2)

        // Reverse of first case, longer delete on operation 2
        // Split into shared delete of n1, with remainder delete of n2 - n1
        } else {
          transformRec(as1.next, as2.withHead(Delete(n2 - n1)), p1, p2)
        }

      // Delete and retain
      case (Some(Delete(n1)), Some(Retain(n2))) =>
        // operation 1 deletes more elements than operation 2 retains, so we need to split delete
        if (n1 > n2) {
          transformRec(as1.withHead(Delete(n1 - n2)), as2.next, p1.delete(n2), p2)

        // Operation 1 deletes exactly the elements retained by operation 2, so do the delete and ignore the retain
        } else if (n1 == n2) {
          transformRec(as1.next, as2.next, p1.delete(n1), p2)

        // Operation 1 deletes fewer elements than operation 2 retains - so do the delete on p1, and then retain
        // fewer elements on p2
        } else {
          transformRec(as1.next, as2.withHead(Retain(n2 - n1)), p1.delete(n1), p2)
        }

      // Retain and delete, mirror image of delete and retain
      case (Some(Retain(n1)), Some(Delete(n2))) =>
        // operation 1 retains more elements than operation 2 deletes, so we need to split the retain
        if (n1 > n2) {
          transformRec(as1.withHead(Retain(n1 - n2)), as2.next, p1, p2.delete(n2))

        // Operation 1 retains the elements deleted by operation 2, so do the delete and ignore the retain
        } else if (n1 == n2) {
          transformRec(as1.next, as2.next, p1, p2.delete(n2))

        // Operation 2 deletes more elements than retained by operation 1, so split the delete
        } else {
          transformRec(as1.next, as2.withHead(Delete(n2 - n1)), p1, p2.delete(n1))
        }

    }


  @tailrec
  private def composeRec[A](as1: List[Atom[A]], as2: List[Atom[A]], c: OperationBuilder[A]): OperationBuilder[A] =
    (as1.headOption, as2.headOption) match {

      // Note use of drop(1) throughout - we don't use tail since this
      // gives an exception when list is empty, and we want to just keep the
      // empty list in this case.

      // If we have processed all atoms, we are done
      case (None, None) => c

      // CASE1 Operation 1 wants to delete
      case (Some(Delete(n1)), _) =>
        composeRec(as1.next, as2, c.delete(n1))

      // CASE2 Operation 2 wants to insert
      case (_, Some(Insert(l2))) =>
        composeRec(as1, as2.next, c.insert(l2))

      // ERR1 Need operation 1 atom
      case (None, _) =>
        sys.error("Composing operations, we ran out of atoms in the first operation")

      // ERR2 Need operation 2 atom
      case (_, None) =>
        sys.error("Composing operations, we ran out of atoms in the second operation")

      // CASE3 Both operations want to retain.
      case (Some(Retain(n1)), Some(Retain(n2))) =>
        // Operation 1 wants to retain more, so perform operation 2's retain first, and update
        // operation 1's retain to just do the remainder of the elements
        if (n1 > n2) {
          composeRec(as1.withHead(Retain(n1 - n2)), as2.next, c.retain(n2))

        // Both operations want to retain same number of elements, so we can just do this to satisfy both.
        } else if (n1 == n2) {
          composeRec(as1.next, as2.next, c.retain(n1))

        // Operation 2 wants to retain more, handle as per first case above but using operation 1's retain
        // first, then the remainder of operation 2's
        } else {
          composeRec(as1.next, as2.withHead(Retain(n2 - n1)), c.retain(n1)) //Note n1 not n2!
        }

      // CASE4 Operation 1 insert, and Operation 2 delete
      case (Some(Insert(l1)), Some(Delete(n2))) =>
        // We are inserting more than we are deleting. So operation 1 will insert the full text after
        // current cursor. Then at the same cursor, operation 2 will delete part of that insertion. This
        // is equivalent to just inserting the elements that are not deleted
        if (l1.size > n2) {
          composeRec(as1.withHead(Insert(l1.drop(n2))), as2.next, c)

        // Operation 2 deletes exactly the elements inserted by operation 1
        } else if (l1.size == n2) {
          composeRec(as1.next, as2.next, c)

        // Operation 2 deletes all the elements inserted by operation 1, then some more. Equivalent to just
        // omitting the insert, and deleting correspondingly less elements
        } else {
          composeRec(as1.next, as2.withHead(Delete(n2 - l1.size)), c)
        }

      // CASE5 Operation 1 insert, operation 2 retain
      case (Some(Insert(l1)), Some(Retain(n2))) =>
        // If we are inserting more than will be retained, then we will break up the insert - we need
        // to insert the elements operation2 will then retain, and postpone inserting the rest
        if (l1.size > n2) {
          composeRec(as1.withHead(Insert(l1.drop(n2))), as2.next, c.insert(l1.take(n2)))

        // Operation 2 wants to retain exactly the inserted elements, so we can just do the insert, and this
        // will also handle the retain
        } else if (l1.size == n2) {
          composeRec(as1.next, as2.next, c.insert(l1))

        // We are inserting less than will be retained. Do the insertion, and then we need to retain the
        // remainder of the count requested by operation 2
        } else {
          composeRec(as1.next, as2.withHead(Retain(n2 - l1.size)), c.insert(l1))
        }

      // CASE6 Operation 1 retain, operation 2 delete
      case (Some(Retain(n1)), Some(Delete(n2))) =>

        // Operation 1 wants to retain more elements than operation 2 deletes. Perform the delete,
        // then retain less characters to account for this
        if (n1 > n2) {
          composeRec(as1.withHead(Retain(n1 - n2)), as2.next, c.delete(n2))

        // Operation 1 retains exactly the deleted elements - just delete them, this achieves the retain
        } else if (n1 == n2) {
          composeRec(as1.next, as2.next, c.delete(n2))

        // Operation 1 retains less elements than are deleted. We need to split the delete.
        } else {
          composeRec(as1.next, as2.withHead(Delete(n2 - n1)), c.delete(n1)) //Note n1 not n2!
        }
    }

}
