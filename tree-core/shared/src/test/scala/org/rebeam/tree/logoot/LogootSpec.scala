package org.rebeam.tree.logoot

import org.rebeam.tree.Guid.SessionId
import org.rebeam.tree.logoot.Logoot._
import org.scalatest.matchers.should.Matchers
import org.scalatest._
import org.scalatestplus.scalacheck.Checkers

import org.scalacheck.Arbitrary._
import org.scalacheck.{Arbitrary, Gen}
import org.scalacheck.Gen._
import cats.implicits._

import org.rebeam.tree.MapStateSTM
import org.rebeam.tree.MapStateSTM._

class LogootSpec extends wordspec.AnyWordSpec with Matchers with Checkers {

  private def assertCompare[A: Ordering](a: A, b: A, result: Int)=
    assert(implicitly[Ordering[A]].compare(a, b) == result, s" - expected $a compare $b to be $result")
  private def assertLessThan[A: Ordering](a: A, b: A) = assertCompare(a, b, -1)
  private def assertMoreThan[A: Ordering](a: A, b: A) = assertCompare(a, b, 1)
  private def assertSame[A: Ordering](a: A, b: A) = assertCompare(a, b, 0)

  val identifierTests: List[(Identifier, Identifier, Int)] = List(
    // Same
    ( Identifier(0, SessionId(0)),
      Identifier(0, SessionId(0)), 0),

    ( Identifier(1, SessionId(1)),
      Identifier(1, SessionId(1)), 0),

    // Differ in pos, not in client
    ( Identifier(0, SessionId(0)),
      Identifier(1, SessionId(0)), -1),

    ( Identifier(1, SessionId(0)),
      Identifier(0, SessionId(0)), 1),

    // Differ in pos, client differs the other way
    ( Identifier(0, SessionId(1)),
      Identifier(1, SessionId(0)), -1),

    ( Identifier(1, SessionId(0)),
      Identifier(0, SessionId(1)), 1),

    // Same in pos, differ in client
    ( Identifier(0, SessionId(0)),
      Identifier(0, SessionId(1)), -1),

    ( Identifier(0, SessionId(1)),
      Identifier(0, SessionId(0)), 1)
  )

  def run[A](m: MapState[A]): A = m.run(MapStateSTM.emptyState).fold(e => sys.error(e.toString), _._2)

  def validIdentifier(p: Int, c: Int, last: Boolean): Identifier = {

    def validPos(x: Int): Int = {
      val abs = Math.abs(x)
      val min = if (last) 1 else 0  // Note we still need to check against 0 even after abs,
      // abs(Int min value) is still negative.
      if (abs < min) min else abs
    }

    Identifier(validPos(p), SessionId(c))
  }

  implicit val pairGen: Gen[(Int, Int)] = implicitly[Arbitrary[(Int, Int)]].arbitrary

  // We ensure that the last identifier in any position generated by positionBetween (and
  // hence any position in a sequence) has a pos > 0. This is required by the algorithm,
  // and guaranteed by its output.
  // Therefore we enforce this invariant in arbitrary positions.
  implicit val arbitraryPosition: Arbitrary[Position] = Arbitrary(
    for {
      l <- Gen.resize(64, listOf[(Int, Int)](pairGen))
      lastPair <- pairGen
    } yield {
      l.map{case (p, c) => validIdentifier(p, c, false)} :+ validIdentifier(lastPair._1, lastPair._2, true)
    }
  )

  "Logoot" should {

    "compare identifiers" in {
      for (t <- identifierTests) assertCompare(t._1, t._2, t._3)
    }

    "compare positions" in {
      // Positions with a single identifier compare as per identifier
      for (t <- identifierTests) assertCompare(List(t._1), List(t._2), t._3)

      val extraId = Identifier(2, SessionId(0))

      // Positions with different lengths compare by identifiers then by length
      for (t <- identifierTests) assertCompare(List(t._1), List(t._2, extraId), if (t._3 != 0) t._3 else -1)
      for (t <- identifierTests) assertCompare(List(t._1, extraId), List(t._2), if (t._3 != 0) t._3 else 1)

      // Adding another equal element gives same comparison
      for (t <- identifierTests) assertCompare(List(t._1, extraId), List(t._2, extraId), t._3)

      // Empty position is less than any non-empty position
      assertSame(Position.empty, Position.empty)
      for (t <- identifierTests) {
        assertLessThan(Position.empty, List(t._1))
        assertLessThan(Position.empty, List(t._2))
      }

      //Check two positions where one is a prefix of the other
      val p = List(
        Identifier(1, SessionId(0)),
        Identifier(1, SessionId(0)),
        Identifier(2, SessionId(0)),
        Identifier(3, SessionId(0)),
        Identifier(4, SessionId(0)),
        Identifier(5, SessionId(0)),
        Identifier(6, SessionId(0)),
        Identifier(7, SessionId(0))
      )
      val q = List(
        Identifier(1, SessionId(0)),
        Identifier(1, SessionId(0)),
        Identifier(2, SessionId(0)),
        Identifier(3, SessionId(0)),
        Identifier(4, SessionId(0)),
        Identifier(5, SessionId(0)),
        Identifier(6, SessionId(0)),
        Identifier(7, SessionId(0)),
        Identifier(8, SessionId(0))
      )
      assertLessThan(p, q)

    }

    // Note these tests use the generated values from a test run, which were checked for correctness,
    // they use pseudo-random values but these are seeded from the DeltaId making them repeatable.
    "construct valid positions between other positions" in {

      def testInsert(p: Position, q: Position, b: Position) = {
        assert (
          run(Position.between[MapState](p, q)) === b
        )

        // Position b must be strictly between p and q
        val po = Logoot.positionOrdering
        assert(po.compare(p, b) == -1)
        assert(po.compare(b, q) == -1)
      }

      // We wouldn't normally have an empty position, but it should work
      testInsert(
        Position.empty,
        List(Identifier(1, SessionId(0))),
        List(Identifier(0,SessionId(0)), Identifier(1569741361, SessionId(0)))
      )

      //Some cases that failed on early implementation with scalacheck

      // An interesting one where we have p < q because of the first ident, but no gap
      // between p and q, so we move to the second ident, where p's ident is > q's ident.
      // This isn't actually an error - we are free to choose any ident > p's ident - the
      // second ident from q doesn't matter since after we incorporate the first ident from
      // p into the result we cannot be > q regardless of subsequent idents.
      testInsert(
        List(Identifier(0,SessionId(0)), Identifier(1692726032,SessionId(0)), Identifier(1,SessionId(0))),
        List(Identifier(1,SessionId(0)), Identifier(109895862,SessionId(0))),
        List(Identifier(0,SessionId(0)), Identifier(1898194551,SessionId(0)))
      )

      //TODO a test case for each of the paths through positionBetweenRec
    }

    "construct valid positions between arbitrary other positions" in {
      check((a: Position, b: Position) => {

        def test(p: Position, q: Position): Boolean = {
          try {

            val po = Logoot.positionOrdering
            val r = run(Position.between[MapState](p, q))

            // Position must be strictly between p and q
            val afterP = po.compare(p, r) == -1
            val beforeQ = po.compare(r, q) == -1

            afterP && beforeQ

            // Workaround for not being able to set scalacheck verbosity for some reason...
            // See https://stackoverflow.com/questions/24396407/how-to-display-entire-stack-trace-for-thrown-exceptions-from-scalacheck-tests
          } catch {
            case t: Throwable =>
              println("Failed to generate positions:")
              t.printStackTrace()
              false
          }

        }

        Logoot.positionOrdering.compare(a, b) match {
          // If we managed to generate two identical positions there is no position between them, so just pass
          case 0 => true

          // Otherwise run the test with the positions in the correct order
          case -1 => test(a, b)
          case _ => test(b, a)
        }
      }, MinSuccessful(100000))
    }

    "repeatedly perform arbitrary insertions maintaining invariants" in {
      pending
    }

  }

}
