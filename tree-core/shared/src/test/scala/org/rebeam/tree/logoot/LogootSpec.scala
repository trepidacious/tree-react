package org.rebeam.tree.logoot

import org.rebeam.tree.Guid.SessionId
import org.rebeam.tree.logoot.Logoot._
import org.scalatest._
import org.scalatest.prop.Checkers
import org.scalacheck.Arbitrary._
import org.scalacheck.{Arbitrary, Gen}
import org.scalacheck.Gen._
import cats.implicits._

import org.rebeam.tree.MapStateSTM
import org.rebeam.tree.MapStateSTM._

class LogootSpec extends WordSpec with Matchers with Checkers {

  def assertCompare[A: Ordering](a: A, b: A, result: Int): Assertion =
    assert(implicitly[Ordering[A]].compare(a, b) == result, s" - expected $a compare $b to be $result")
  def assertLessThan[A: Ordering](a: A, b: A): Assertion = assertCompare(a, b, -1)
  def assertMoreThan[A: Ordering](a: A, b: A): Assertion = assertCompare(a, b, 1)
  def assertSame[A: Ordering](a: A, b: A): Assertion = assertCompare(a, b, 0)

  val identifierTests: List[(Identifier, Identifier, Int)] = List(
    // Same
    ( Identifier(0, SessionId(0)),
      Identifier(0, SessionId(0)), 0),

    ( Identifier(1, SessionId(1)),
      Identifier(1, SessionId(1)), 0),

    // Differ in pos, not in client
    ( Identifier(0, SessionId(0)),
      Identifier(1, SessionId(0)), -1),

    ( Identifier(1, SessionId(0)),
      Identifier(0, SessionId(0)), 1),

    // Differ in pos, client differs the other way
    ( Identifier(0, SessionId(1)),
      Identifier(1, SessionId(0)), -1),

    ( Identifier(1, SessionId(0)),
      Identifier(0, SessionId(1)), 1),

    // Same in pos, differ in client
    ( Identifier(0, SessionId(0)),
      Identifier(0, SessionId(1)), -1),

    ( Identifier(0, SessionId(1)),
      Identifier(0, SessionId(0)), 1)
  )

  def run[A](m: MapState[A]): A = m.run(MapStateSTM.emptyState).fold(e => sys.error(e.toString), _._2)

  def validIdentifier(p: Int, c: Int, last: Boolean): Identifier = {

    def validPos(x: Int): Int = {
      val abs = Math.abs(x)
      val min = if (last) 1 else 0  // Note we still need to check against 0 even after abs,
      // abs(Int min value) is still negative.
      if (abs < min) min else abs
    }

    Identifier(validPos(p), SessionId(c))
  }

  implicit val pairGen: Gen[(Int, Int)] = implicitly[Arbitrary[(Int, Int)]].arbitrary

  // We ensure that the last identifier in any position generated by positionBetween (and
  // hence any position in a sequence) has a pos > 0. This is required by the algorithm,
  // and guaranteed by its output.
  // Therefore we enforce this invariant in arbitrary positions.
  implicit val arbitraryPosition: Arbitrary[Position] = Arbitrary(
    for {
      l <- Gen.resize(64, listOf[(Int, Int)](pairGen))
      lastPair <- pairGen
    } yield {
      l.map{case (p, c) => validIdentifier(p, c, false)} :+ validIdentifier(lastPair._1, lastPair._2, true)
    }
  )

  "Logoot" should {
    "compare identifiers" in {
      for (t <- identifierTests) assertCompare(t._1, t._2, t._3)

    }
    "compare positions" in {
      // Positions with a single identifier compare as per identifier
      for (t <- identifierTests) assertCompare(List(t._1), List(t._2), t._3)

      val extraId = Identifier(2, SessionId(0))

      // Positions with different lengths compare by identifiers then by length
      for (t <- identifierTests) assertCompare(List(t._1), List(t._2, extraId), if (t._3 != 0) t._3 else -1)
      for (t <- identifierTests) assertCompare(List(t._1, extraId), List(t._2), if (t._3 != 0) t._3 else 1)

      // Adding another equal element gives same comparison
      for (t <- identifierTests) assertCompare(List(t._1, extraId), List(t._2, extraId), t._3)

      // Empty position is less than any non-empty position
      assertSame(Position.empty, Position.empty)
      for (t <- identifierTests) {
        assertLessThan(Position.empty, List(t._1))
        assertLessThan(Position.empty, List(t._2))
      }

      //Check two positions where one is a prefix of the other
      val p = List(
        Identifier(1, SessionId(0)),
        Identifier(1, SessionId(0)),
        Identifier(2, SessionId(0)),
        Identifier(3, SessionId(0)),
        Identifier(4, SessionId(0)),
        Identifier(5, SessionId(0)),
        Identifier(6, SessionId(0)),
        Identifier(7, SessionId(0))
      )
      val q = List(
        Identifier(1, SessionId(0)),
        Identifier(1, SessionId(0)),
        Identifier(2, SessionId(0)),
        Identifier(3, SessionId(0)),
        Identifier(4, SessionId(0)),
        Identifier(5, SessionId(0)),
        Identifier(6, SessionId(0)),
        Identifier(7, SessionId(0)),
        Identifier(8, SessionId(0))
      )
      assertLessThan(p, q)

    }

    "construct positions between other positions" in {

      //      val p = Position(List(          //01
      //        Identifier(0, SessionId(0)),
      //        Identifier(1, SessionId(1))
      //      ))
      //      val q = Position(List(          //02
      //        Identifier(0, SessionId(2)),
      //        Identifier(2, SessionId(3))
      //      ))
      //      val r = Position(List(          //03
      //        Identifier(0, SessionId(4)),
      //        Identifier(3, SessionId(5))
      //      ))
      //
      //      // There are no 2 digit positions between p and q, so we end up
      //      // adding a new digit, at 1
      //      assert (
      //        run(Position.between(p, q, 1))
      //          ===
      //        List(
      //          Position(List(
      //            Identifier(0,SessionId(0)),
      //            Identifier(1,SessionId(1)),
      //            Identifier(1,SessionId(99))
      //          ))
      //        )
      //      )
      //
      //      // There is a single 1 digit position between p and r, 02
      //      assert (
      //        run(Position.between(p, r, 1))
      //          ===
      //          List(
      //            Position(List(
      //              Identifier(0,SessionId(0)),
      //              Identifier(2,SessionId(99))
      //            ))
      //          )
      //      )
      //
      //      val s = Position(List(          //06
      //        Identifier(0, SessionId(6)),
      //        Identifier(6, SessionId(7))
      //      ))
      //
      //      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 4
      //      // Will use a step of 1, giving exactly each code
      //      assert(
      //        run(Position.between(p, s, 4))
      //          ===
      //        List(
      //          Position(List(Identifier(0,SessionId(0)), Identifier(2,SessionId(99)))),    //02
      //          Position(List(Identifier(0,SessionId(0)), Identifier(3,SessionId(99)))),    //03
      //          Position(List(Identifier(0,SessionId(0)), Identifier(4,SessionId(99)))),    //04
      //          Position(List(Identifier(0,SessionId(0)), Identifier(5,SessionId(99))))     //05
      //        )
      //      )
      //
      //      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 3
      //      // 3 codes from 4 options means step size 1, so we get the first 3 options
      //      assert(
      //        run(Position.between(p, s, 3))
      //          ===
      //          List(
      //            Position(List(Identifier(0,SessionId(0)), Identifier(2,SessionId(99)))),    //02
      //            Position(List(Identifier(0,SessionId(0)), Identifier(3,SessionId(99)))),    //03
      //            Position(List(Identifier(0,SessionId(0)), Identifier(4,SessionId(99))))    //04
      //          )
      //      )
      //
      //      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 2
      //      // 2 codes from 4 options means step size 2, so we get the 1st and 3rd option
      //      assert(
      //        run(Position.between(p, s, 2))
      //          ===
      //          List(
      //            Position(List(Identifier(0,SessionId(0)), Identifier(2,SessionId(99)))),    //02
      //            Position(List(Identifier(0,SessionId(0)), Identifier(4,SessionId(99))))    //04
      //          )
      //      )
      //
      //      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 1
      //      // 1 codes from 4 options means step size 4, so we get the 1st option only
      //      assert(
      //        run(Position.between(p, s, 1))
      //          ===
      //          List(
      //            Position(List(Identifier(0,SessionId(0)), Identifier(2,SessionId(99))))    //02
      //          )
      //      )
      //
      //
      //      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 5
      //      // We therefore require more digits.
      //      // Considered as 3 digit codes, 060 - 010 is 5 * base = 5 * 2147483648 = 10737418240
      //      // This gives 10737418240 - 1 = 10737418239 options, divided by 5 requested codes
      //      // gives a window of 2147483647.8, rounded down to 2147483647 for each code.
      //      // The first code is always at + 1, so we go from 01 to 011,
      //      // then each subsequent code is at i steps of 2147483647 from this.
      //      // 2147483647 is the base - 1, the maximum int value m, so we get 011, then 020, then 02m, then 03(m-1) and so on
      //      assert(
      //        run(Position.between(p, s, 5))
      //          ===
      //        List(
      //          Position(List(Identifier(0,SessionId(0)), Identifier(1,SessionId(1)), Identifier(1,SessionId(99)))),           //011
      //          Position(List(Identifier(0,SessionId(0)), Identifier(2,SessionId(99)), Identifier(0,SessionId(99)))),          //020
      //          Position(List(Identifier(0,SessionId(0)), Identifier(2,SessionId(99)), Identifier(2147483647,SessionId(99)))), //02m
      //          Position(List(Identifier(0,SessionId(0)), Identifier(3,SessionId(99)), Identifier(2147483646,SessionId(99)))), //03(m-1)
      //          Position(List(Identifier(0,SessionId(0)), Identifier(4,SessionId(99)), Identifier(2147483645,SessionId(99))))  //04(m-2)
      //        )
      //      )
      //
      //      // Test a gap for 1 2-digit code (01 to 03), when requesting 2
      //      // We again require more digits, and get 030-010 = 2 * base,
      //      // and so 2 * base - 1 = 4294967295 options. Divided by 2 code
      //      // we get 2147483647.5 rounding down to 2147483647, so as above
      //      // we get 011 then 020
      //      assert (
      //        run(Position.between(p, r, 2))
      //          ===
      //        List(
      //          Position(List(Identifier(0,SessionId(0)), Identifier(1,SessionId(1)), Identifier(1,SessionId(99)))), //011
      //          Position(List(Identifier(0,SessionId(0)), Identifier(2,SessionId(99)), Identifier(0,SessionId(99)))) //020
      //        )
      //      )
      //
      //      val p = Position(List(
      //        Identifier(1, SessionId(0)),
      //        Identifier(1, SessionId(1)),
      //        Identifier(2, SessionId(2)),
      //        Identifier(3, SessionId(3)),
      //        Identifier(4, SessionId(4)),
      //        Identifier(5, SessionId(5)),
      //        Identifier(6, SessionId(6)),
      //        Identifier(7, SessionId(7))
      //      ))
      //      val q = Position(List(
      //        Identifier(1, SessionId(8)),
      //        Identifier(1, SessionId(9)),
      //        Identifier(2, SessionId(10)),
      //        Identifier(3, SessionId(11)),
      //        Identifier(4, SessionId(12)),
      //        Identifier(5, SessionId(13)),
      //        Identifier(6, SessionId(14)),
      //        Identifier(7, SessionId(15)),
      //        Identifier(8, SessionId(16))
      //      ))
      ////      run(Position.between(q, p, 2))
      //      println(s"$p compare to $q is ${Logoot.positionOrdering.compare(p, q)}")
    }

    // Note these tests use the generated values from a test run, which were checked for correctness,
    // they use pseudo-random values but these are seeded from the DeltaId making them repeatable.
    "construct valid positions between other positions" in {

      def testInsert(p: Position, q: Position, b: Position) = {
        assert (
          run(Position.between[MapState](p, q)) === b
        )

        // Position b must be strictly between p and q
        val po = Logoot.positionOrdering
        assert(po.compare(p, b) == -1)
        assert(po.compare(b, q) == -1)
      }

      // We wouldn't normally have an empty position, but it should work
      testInsert(
        Position.empty,
        List(Identifier(1, SessionId(0))),
        List(Identifier(0,SessionId(0)), Identifier(1569741361, SessionId(0)))
      )

      //Some cases that failed on early implementation with scalacheck

      // An interesting one where we have p < q because of the first ident, but no gap
      // between p and q, so we move to the second ident, where p's ident is > q's ident.
      // This isn't actually an error - we are free to choose any ident > p's ident - the
      // second ident from q doesn't matter since after we incorporate the first ident from
      // p into the result we cannot be > q regardless of subsequent idents.
      testInsert(
        List(Identifier(0,SessionId(0)), Identifier(1692726032,SessionId(0)), Identifier(1,SessionId(0))),
        List(Identifier(1,SessionId(0)), Identifier(109895862,SessionId(0))),
        List(Identifier(0,SessionId(0)), Identifier(1898194551,SessionId(0)))
      )

      //TODO a test case for each of the paths through positionBetweenRec
    }

    "construct valid positions between arbitrary other positions" in {
      check((a: Position, b: Position) => {

        def test(p: Position, q: Position): Boolean = {
          try {

            val po = Logoot.positionOrdering
            val r = run(Position.between[MapState](p, q))

            // Position must be strictly between p and q
            val afterP = po.compare(p, r) == -1
            val beforeQ = po.compare(r, q) == -1

            afterP && beforeQ

            // Workaround for not being able to set scalacheck verbosity for some reason...
            // See https://stackoverflow.com/questions/24396407/how-to-display-entire-stack-trace-for-thrown-exceptions-from-scalacheck-tests
          } catch {
            case t: Throwable =>
              println("Failed to generate positions:")
              t.printStackTrace()
              false
          }

        }

        Logoot.positionOrdering.compare(a, b) match {
          // If we managed to generate two identical positions there is no position between them, so just pass
          case 0 => true

          // Otherwise run the test with the positions in the correct order
          case -1 => test(a, b)
          case _ => test(b, a)
        }
      }, MinSuccessful(100000))
    }

    "repeatedly perform arbitrary insertions maintaining invariants" in {
      pending
    }

  }

}
