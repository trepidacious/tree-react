package org.rebeam.tree

import io.circe._
import io.circe.generic.JsonCodec
import Guid._

import scala.util.Try
import scala.util.matching.Regex

/**
  * General-purpose identifier, unique within a given scope (at least a single server)
  *
  * Guids are always generated in a Transaction, and take their indices from that
  * Transaction, plus an incrementing transactionClock within that transaction.
  *
  * This is a generic identifier without an association with an item of data, or type of data, and as
  * such is just a unique token. Use IdOf to associate to a particular data type.
  *
  * @param sessionId              Session id
  * @param sessionTransactionId   Id of Transaction within Session
  * @param transactionClock        Id of the Guid within the Transaction
  */
case class Guid(sessionId: SessionId, sessionTransactionId: SessionTransactionId, transactionClock: TransactionClock) {
  override def toString: String = Guid.toString(this)
  def nextSessionFirstGuid: Guid = copy(sessionId = sessionId.next, sessionTransactionId = SessionTransactionId(0), transactionClock = TransactionClock(0))
  def nextTransactionFirstGuid: Guid = copy(sessionTransactionId = sessionTransactionId.next, transactionClock = TransactionClock(0))
  def next: Guid = copy(transactionClock = transactionClock.next)
}

object Guid {

  val first: Guid = Guid.raw(0, 0, 0)

  /**
    * Identifier for a session on the server, identifies a client's connection to the server.
    * Unique for a given scope (at least a single server).
    * Assigned by a server.
    *
    * @param id The identifier value
    */
  @JsonCodec
  case class SessionId(id: Long) extends AnyVal {
    def next: SessionId = SessionId(id + 1)
  }

  /**
    * Identifier for a transaction, unique for a given session but not globally.
    * Assigned by a client as part of the session, incrementing from 0.
    *
    * @param id The identifier value
    */
  @JsonCodec
  case class SessionTransactionId(id: Long) extends AnyVal {
    def next: SessionTransactionId = SessionTransactionId(id + 1)
  }

  /**
    * Identifier for a guid within a Transaction, unique for that Transaction but not globally.
    * Generated by the TransactionContext, incrementing from 0 within a transaction.
    *
    * @param id The identifier value
    */
  @JsonCodec
  case class TransactionClock(id: Long) extends AnyVal {
    def next: TransactionClock = TransactionClock(id + 1)
  }

  val regex: Regex = "([Gg][Uu][Ii][Dd]-[0-9a-fA-F]+-[0-9a-fA-F]+-[0-9a-fA-F]+)".r
  val regexGrouped: Regex = "[Gg][Uu][Ii][Dd]-([0-9a-fA-F]+)-([0-9a-fA-F]+)-([0-9a-fA-F]+)".r

  private def hex(x: String): Long = java.lang.Long.parseUnsignedLong(x, 16)

  def fromString(s: String): Option[Guid] = s match {
    case regexGrouped(sessionId, sessionTransactionId, transactionClock) =>
      Try {
        Guid(SessionId(hex(sessionId)), SessionTransactionId(hex(sessionTransactionId)), TransactionClock(hex(transactionClock)))
      }.toOption
    case _ => None
  }

  def toString(g: Guid): String = f"guid-${g.sessionId.id}%x-${g.sessionTransactionId.id}%x-${g.transactionClock.id}%x"

  //Encoder and decoder using plain string format for guid

  implicit val decodeGuid: Decoder[Guid] = Decoder.instance(
    c => c.as[String].flatMap(string => fromString(string).fold[Either[DecodingFailure, Guid]](Left(DecodingFailure("Guid invalid string", c.history)))(Right(_)))
  )
  implicit val encodeGuid: Encoder[Guid] = Encoder.instance(
    g => Json.fromString(toString(g))
  )

  implicit val guidKeyEncoder: KeyEncoder[Guid] = KeyEncoder.instance(Guid.toString)
  implicit val guidKeyDecoder: KeyDecoder[Guid] = KeyDecoder.instance(Guid.fromString)

  def raw(sid: Long, stid: Long, tc: Long): Guid =
    Guid(SessionId(sid), SessionTransactionId(stid), TransactionClock(tc))

}
